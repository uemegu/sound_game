<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Cyber Rhythm</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --neon-blue: #00f3ff;
        --neon-pink: #ff00ff;
        --neon-purple: #bc13fe;
        --bg-dark: #050510;
        --lane-width-max: 600px;
      }

      * {
        box-sizing: border-box;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background-color: var(--bg-dark);
        font-family: "Rajdhani", sans-serif;
        color: #fff;
      }

      /* --- 背景レイヤー --- */
      #background-layer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        pointer-events: none;
        background: radial-gradient(circle at 50% 30%, #1a1a2e 0%, #000000 90%);
      }
      #visualizer,
      #particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #visualizer {
        opacity: 0.6;
        mix-blend-mode: screen;
      }

      /* --- メニュー画面 --- */
      #menu {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2000;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 20px;
        overflow-y: auto;
        backdrop-filter: blur(10px);
      }

      #menu h1 {
        font-family: "Orbitron", sans-serif;
        font-size: 48px;
        margin-bottom: 30px;
        background: linear-gradient(
          90deg,
          var(--neon-blue),
          #fff,
          var(--neon-pink)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 0 20px var(--neon-purple);
      }

      #track-selection {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        width: 100%;
        max-width: 800px;
      }

      .track-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(0, 243, 255, 0.3);
        border-radius: 12px;
        padding: 15px;
        display: flex;
        align-items: center;
        cursor: pointer;
        transition: all 0.2s;
      }
      .track-card:active {
        transform: scale(0.95);
        background: rgba(0, 243, 255, 0.1);
      }
      .track-card img {
        width: 60px;
        height: 60px;
        border-radius: 8px;
        margin-right: 15px;
        object-fit: cover;
      }
      .track-info h2 {
        margin: 0;
        font-size: 18px;
        color: #fff;
      }
      .track-info p {
        margin: 5px 0 0;
        font-size: 14px;
        color: var(--neon-blue);
      }

      /* --- ゲーム画面 --- */
      #game-container {
        position: relative;
        width: 100%;
        height: 100%;
        display: none;
        overflow: hidden;
      }

      /* 3Dシーン */
      #scene-3d {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        perspective: 800px;
        perspective-origin: 50% 40%;
        z-index: 10;
        pointer-events: none;
      }

      #lanes-plane {
        position: absolute;
        left: 50%;
        bottom: -20%;
        width: 100%;
        max-width: var(--lane-width-max);
        height: 200%;
        transform: translateX(-50%) rotateX(55deg);
        transform-style: preserve-3d;
        transform-origin: center bottom;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0) 0%,
          rgba(0, 40, 80, 0.3) 50%,
          rgba(0, 20, 40, 0.6) 100%
        );
        border-left: 2px solid rgba(255, 255, 255, 0.1);
        border-right: 2px solid rgba(255, 255, 255, 0.1);
      }

      /* グリッド線 */
      #lanes-plane::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: linear-gradient(
          90deg,
          transparent 0%,
          transparent 24.5%,
          rgba(255, 255, 255, 0.1) 25%,
          transparent 25.5%,
          transparent 49.5%,
          rgba(255, 255, 255, 0.1) 50%,
          transparent 50.5%,
          transparent 74.5%,
          rgba(255, 255, 255, 0.1) 75%,
          transparent 75.5%
        );
        z-index: 1;
      }

      /* タップ時のレーン発光 */
      .lane-flash {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 25%;
        background: linear-gradient(
          180deg,
          transparent 0%,
          rgba(0, 243, 255, 0.3) 80%,
          rgba(0, 243, 255, 0.6) 100%
        );
        opacity: 0;
        transition: opacity 0.05s;
        z-index: 2;
        mix-blend-mode: screen;
      }
      .lane-flash[data-lane="0"] {
        left: 0%;
      }
      .lane-flash[data-lane="1"] {
        left: 25%;
      }
      .lane-flash[data-lane="2"] {
        left: 50%;
      }
      .lane-flash[data-lane="3"] {
        left: 75%;
      }
      .lane-flash.active {
        opacity: 1;
      }

      /* 判定ライン */
      #judgement-line {
        position: absolute;
        bottom: 15%;
        left: 0;
        width: 100%;
        height: 8px;
        background: #00f3ff;
        box-shadow: 0 0 10px #00f3ff, 0 0 20px #fff;
        z-index: 20;
        transform: translateZ(2px);
      }

      /* ノート */
      .note {
        position: absolute;
        width: 23%;
        background: var(--neon-pink);
        box-shadow: 0 0 15px var(--neon-pink),
          inset 0 0 5px rgba(255, 255, 255, 0.8);
        border-radius: 4px;
        transform-origin: bottom center;
        z-index: 10;
      }
      .note[data-lane="0"] {
        left: 1%;
        background: var(--neon-blue);
        box-shadow: 0 0 15px var(--neon-blue);
      }
      .note[data-lane="1"] {
        left: 26%;
      }
      .note[data-lane="2"] {
        left: 51%;
      }
      .note[data-lane="3"] {
        left: 76%;
        background: var(--neon-blue);
        box-shadow: 0 0 15px var(--neon-blue);
      }

      .note.long {
        opacity: 0.9;
      }
      .note.long::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
          0deg,
          rgba(255, 255, 255, 0.4) 0,
          transparent 20px
        );
      }

      /* --- 2D HUD レイヤー --- */
      #hud-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 100;
        pointer-events: none;
      }

      #input-grid {
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: var(--lane-width-max);
        height: 40%;
        display: flex;
        pointer-events: auto;
        z-index: 110;
      }
      .input-zone {
        flex: 1;
        position: relative;
      }

      .key-guide {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        font-family: "Orbitron";
        font-size: 20px;
        color: rgba(255, 255, 255, 0.5);
        font-weight: bold;
        pointer-events: none;
      }

      #score-header {
        position: absolute;
        top: 0;
        width: 100%;
        padding: 20px;
        display: flex;
        justify-content: space-between;
        pointer-events: auto;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.8) 0%,
          transparent 100%
        );
      }
      #score-display {
        text-align: right;
        font-family: "Orbitron";
      }
      #score-val {
        font-size: 32px;
        color: #fff;
        text-shadow: 0 0 10px var(--neon-blue);
      }

      #abort-btn {
        background: transparent;
        border: 1px solid var(--neon-pink);
        color: var(--neon-pink);
        padding: 8px 24px;
        font-family: "Orbitron";
        cursor: pointer;
        font-weight: bold;
        transition: 0.2s;
      }
      #abort-btn:hover {
        background: var(--neon-pink);
        color: #000;
      }

      #combo-container {
        position: absolute;
        top: 35%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        opacity: 0;
        transition: transform 0.05s;
        pointer-events: none;
      }
      #combo-container.show {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
      #combo-num {
        font-family: "Orbitron";
        font-size: 90px;
        color: #fff;
        text-shadow: 0 0 20px var(--neon-blue);
        line-height: 1;
      }
      #combo-text {
        font-family: "Rajdhani";
        font-size: 24px;
        color: var(--neon-pink);
        letter-spacing: 5px;
        font-weight: bold;
      }

      .feedback-text {
        position: absolute;
        bottom: 45%;
        left: 50%;
        transform: translateX(-50%);
        font-family: "Orbitron";
        font-weight: 900;
        font-size: 40px;
        text-shadow: 0 0 10px currentColor;
        animation: popUp 0.5s ease-out forwards;
        z-index: 120;
        pointer-events: none;
        white-space: nowrap;
      }
      @keyframes popUp {
        0% {
          opacity: 0;
          transform: translate(-50%, 20px) scale(0.8);
        }
        20% {
          opacity: 1;
          transform: translate(-50%, 0) scale(1.2);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50px) scale(1);
        }
      }

      #result-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 3000;
        backdrop-filter: blur(15px);
      }
      #retry-btn {
        margin-top: 30px;
        padding: 15px 60px;
        background: linear-gradient(
          45deg,
          var(--neon-purple),
          var(--neon-blue)
        );
        border: none;
        border-radius: 30px;
        color: #fff;
        font-family: "Orbitron";
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
      }

      @media (max-width: 768px) {
        #lanes-plane,
        #input-grid {
          width: 110%;
        }
        .key-guide {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <audio id="main-audio"></audio>

    <div id="background-layer">
      <canvas id="visualizer"></canvas>
      <canvas id="particles"></canvas>
    </div>

    <div id="menu">
      <h1>Cyber Rhythm</h1>
      <div id="track-selection"></div>
    </div>

    <div id="game-container">
      <div id="scene-3d">
        <div id="lanes-plane">
          <!-- レーン発光 -->
          <div class="lane-flash" data-lane="0"></div>
          <div class="lane-flash" data-lane="1"></div>
          <div class="lane-flash" data-lane="2"></div>
          <div class="lane-flash" data-lane="3"></div>
          <!-- 判定ライン -->
          <div id="judgement-line"></div>
          <!-- ノート生成場所 -->
          <div id="notes-container"></div>
        </div>
      </div>

      <div id="hud-layer">
        <div id="score-header">
          <button id="abort-btn">ABORT</button>
          <div id="score-display">
            <div style="font-size: 12px; color: #888">SCORE</div>
            <div id="score-val">0</div>
          </div>
        </div>

        <div id="combo-container">
          <div id="combo-num">0</div>
          <div id="combo-text">COMBO</div>
        </div>

        <div id="input-grid">
          <div class="input-zone" data-key="key1">
            <div class="key-guide">D</div>
          </div>
          <div class="input-zone" data-key="key2">
            <div class="key-guide">F</div>
          </div>
          <div class="input-zone" data-key="key3">
            <div class="key-guide">J</div>
          </div>
          <div class="input-zone" data-key="key4">
            <div class="key-guide">K</div>
          </div>
        </div>
      </div>
    </div>

    <div id="result-screen">
      <h1
        style="
          font-family: 'Orbitron';
          color: var(--neon-blue);
          font-size: 48px;
        "
      >
        COMPLETE
      </h1>
      <div
        id="result-stats"
        style="
          text-align: center;
          color: #fff;
          font-size: 24px;
          line-height: 1.8;
        "
      ></div>
      <button id="retry-btn">RETRY</button>
    </div>

    <script>
      const HIT_POS_Y = 85;
      const APPROACH_TIME = 1500;
      const SPAWN_LOOKAHEAD = 1500;
      const SPEED_PCT = HIT_POS_Y / APPROACH_TIME;
      // ミス判定のマージンを判定窓(250ms)より広く取る
      const MISS_THRESHOLD = -300;

      const KEY_MAP = { d: "key1", f: "key2", j: "key3", k: "key4" };
      const LANE_INDEX = { key1: 0, key2: 1, key3: 2, key4: 3 };

      let currentTrack = null;
      let allNotes = [];
      let activeNotes = [];
      let nextSpawnIdx = 0;

      let score = 0,
        combo = 0,
        maxCombo = 0;
      let isPlaying = false;
      let animationId = null;

      let audioCtx, analyser, dataArray;
      const audio = document.getElementById("main-audio");

      const notesContainer = document.getElementById("notes-container");
      const scoreEl = document.getElementById("score-val");
      const comboBox = document.getElementById("combo-container");
      const comboNum = document.getElementById("combo-num");
      const laneFlashes = document.querySelectorAll(".lane-flash");

      let activeKeys = new Set();
      let longNoteHold = { key1: null, key2: null, key3: null, key4: null };

      const vCanvas = document.getElementById("visualizer");
      const vCtx = vCanvas.getContext("2d");
      const pCanvas = document.getElementById("particles");
      const pCtx = pCanvas.getContext("2d");
      let particles = [];

      window.addEventListener("load", () => {
        resizeCanvases();
        window.addEventListener("resize", resizeCanvases);
        loadTracks();
        setupInputs();
        requestAnimationFrame(visualLoop);
      });

      function resizeCanvases() {
        vCanvas.width = window.innerWidth;
        vCanvas.height = window.innerHeight;
        pCanvas.width = window.innerWidth;
        pCanvas.height = window.innerHeight;
      }

      function loadTracks() {
        fetch("data/tracks.json")
          .then((r) => r.json())
          .then((tracks) => {
            const list = document.getElementById("track-selection");
            list.innerHTML = "";
            tracks.forEach((t) => {
              const el = document.createElement("div");
              el.className = "track-card";
              el.innerHTML = `<img src="${t.cover}"><div class="track-info"><h2>${t.title}</h2><p>Lv.${t.difficulty}</p></div>`;
              el.onclick = () => initGame(t);
              list.appendChild(el);
            });
          })
          .catch((e) => console.error("Error loading tracks", e));
      }

      function stopGameLoop() {
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
      }

      function resetGame() {
        stopGameLoop();

        score = 0;
        combo = 0;
        maxCombo = 0;
        updateScore();
        comboBox.classList.remove("show");

        allNotes = [];
        activeNotes = [];
        nextSpawnIdx = 0;
        notesContainer.innerHTML = "";

        activeKeys.clear();
        longNoteHold = { key1: null, key2: null, key3: null, key4: null };
        laneFlashes.forEach((el) => el.classList.remove("active"));

        isPlaying = false;
      }

      async function initGame(track) {
        currentTrack = track;
        resetGame();

        document.getElementById("menu").style.display = "none";
        document.getElementById("result-screen").style.display = "none";
        document.getElementById("game-container").style.display = "block";

        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioCtx.createAnalyser();
          analyser.fftSize = 256;
          const src = audioCtx.createMediaElementSource(audio);
          src.connect(analyser);
          analyser.connect(audioCtx.destination);
          dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        audio.src = track.audio;
        const res = await fetch(track.json);
        const data = await res.json();

        allNotes = data.notes
          .map((n) => ({
            ...n,
            laneKey: normalizeLane(n.type),
            start: Number(n.start_msec),
            dur: Number(n.duration_msec || 0),
            spawned: false,
            hit: false,
            processed: false,
            el: null,
          }))
          .sort((a, b) => a.start - b.start);

        try {
          await audio.play();
          isPlaying = true;
          gameLoop();
        } catch (e) {
          console.error(e);
        }
      }

      function normalizeLane(key) {
        const map = {
          key1: "key1",
          key2: "key2",
          key3: "key3",
          key4: "key4",
          key5: "key3",
          key6: "key4",
        };
        return map[key] || "key1";
      }

      function visualLoop() {
        if (!isPlaying) {
          drawVisualizer();
          updateParticles();
          requestAnimationFrame(visualLoop);
        }
      }

      function gameLoop() {
        animationId = requestAnimationFrame(gameLoop);

        drawVisualizer();
        updateParticles();

        if (!isPlaying) return;
        if (audio.paused) return;

        const now = audio.currentTime * 1000;

        // 1. Spawn
        while (nextSpawnIdx < allNotes.length) {
          const note = allNotes[nextSpawnIdx];
          if (!note.spawned && note.start <= now + SPAWN_LOOKAHEAD) {
            spawnNote(note);
            nextSpawnIdx++;
          } else {
            break;
          }
        }

        // 2. Update
        const toRemove = [];

        activeNotes.forEach((note, idx) => {
          // 処理済み(Processed)ノートの片付け
          if (note.processed) {
            // 成功(Hit)していて、ロングノートホールド中でなければ削除
            if (note.hit) {
              if (note.el) note.el.style.display = "none";
              if (longNoteHold[note.laneKey] !== note) {
                toRemove.push(idx);
              }
            } else {
              // Missしたノート: 透明にして画面外へ流す
              if (note.el) note.el.style.opacity = 0.3;
              const endT = note.start + note.dur;
              if (endT < now - 1000) toRemove.push(idx);
            }
            // 位置計算だけ続ける(Miss用)
            if (note.hit && note.processed) return;
          }

          // 位置計算
          const timeToHit = note.start - now;
          let currentTop = HIT_POS_Y - timeToHit * SPEED_PCT;

          // ロングノートホールド中
          if (longNoteHold[note.laneKey] === note) {
            const endTime = note.start + note.dur;
            const remain = endTime - now;
            if (remain <= 0) {
              completeLongNote(note);
            } else {
              note.el.style.top = HIT_POS_Y + "%";
              const hPct = Math.max(0, remain * SPEED_PCT);
              note.el.style.height = hPct + "%";
              note.el.style.filter = "brightness(1.5)";
              if (Math.random() > 0.5) spawnSparkle(note.laneKey);
            }
          } else {
            // 通常移動
            if (note.el) {
              note.el.style.top = currentTop + "%";

              // --- Miss判定 (ここが修正ポイント) ---
              // まだHitしておらず、processedでもない場合
              if (!note.processed && !note.hit) {
                // 時間超過でMiss
                if (timeToHit < MISS_THRESHOLD) {
                  triggerMiss(note);
                }
              }
            }
          }
        });

        for (let i = toRemove.length - 1; i >= 0; i--) {
          removeNote(toRemove[i]);
        }

        if (audio.ended) endGame();
      }

      function spawnNote(note) {
        if (note.spawned) return;
        note.spawned = true;

        const el = document.createElement("div");
        el.className = "note";
        if (note.dur > 0) el.classList.add("long");
        el.dataset.lane = LANE_INDEX[note.laneKey];

        const hPct = Math.max(2, note.dur * SPEED_PCT);
        el.style.height = hPct + "%";
        el.style.top = "-100%";

        notesContainer.appendChild(el);
        note.el = el;
        activeNotes.push(note);
      }

      function removeNote(idx) {
        if (idx >= activeNotes.length) return;
        const note = activeNotes[idx];
        if (note.el && note.el.parentNode) {
          note.el.parentNode.removeChild(note.el);
        }
        note.el = null;
        activeNotes.splice(idx, 1);
      }

      /* --- 入力ハンドリング --- */
      function setupInputs() {
        const zones = document.querySelectorAll(".input-zone");
        zones.forEach((z) => {
          const k = z.dataset.key;
          const start = (e) => {
            if (e.cancelable) e.preventDefault();
            handleInputStart(k);
          };
          const end = (e) => {
            if (e.cancelable) e.preventDefault();
            handleInputEnd(k);
          };

          z.addEventListener("touchstart", start, { passive: false });
          z.addEventListener("touchend", end);
          z.addEventListener("mousedown", start);
          z.addEventListener("mouseup", end);
          z.addEventListener("mouseout", end);
        });

        document.addEventListener("keydown", (e) => {
          if (e.repeat || !isPlaying) return;
          const k = KEY_MAP[e.key.toLowerCase()];
          if (k) handleInputStart(k);
        });
        document.addEventListener("keyup", (e) => {
          const k = KEY_MAP[e.key.toLowerCase()];
          if (k) handleInputEnd(k);
        });

        document.getElementById("abort-btn").onclick = () => {
          audio.pause();
          isPlaying = false;
          resetGame();
          document.getElementById("game-container").style.display = "none";
          document.getElementById("menu").style.display = "flex";
          requestAnimationFrame(visualLoop);
        };
        document.getElementById("retry-btn").onclick = () => {
          if (currentTrack) initGame(currentTrack);
        };
      }

      function handleInputStart(key) {
        if (activeKeys.has(key)) return;
        activeKeys.add(key);

        const idx = LANE_INDEX[key];
        const flash = document.querySelector(`.lane-flash[data-lane="${idx}"]`);
        if (flash) flash.classList.add("active");

        const now = audio.currentTime * 1000;

        const target = activeNotes.find(
          (n) =>
            n.laneKey === key && !n.processed && Math.abs(n.start - now) < 250
        );

        if (target) {
          const diff = Math.abs(target.start - now);
          let j = "BAD",
            pts = 0,
            col = "#aaa";
          if (diff < 50) {
            j = "PERFECT";
            pts = 500;
            col = "#f0f";
          } else if (diff < 120) {
            j = "GREAT";
            pts = 300;
            col = "#0ff";
          } else if (diff < 250) {
            j = "GOOD";
            pts = 100;
            col = "#0f0";
          }

          showFeedback(key, j, col);
          spawnHitEffect(key, col);

          if (target.dur > 500) {
            longNoteHold[key] = target;
            target.hit = true;
            addScore(pts);
          } else {
            target.hit = true;
            target.processed = true;
            if (target.el) target.el.style.display = "none";
            addScore(pts);
          }
        }
      }

      function handleInputEnd(key) {
        activeKeys.delete(key);
        const idx = LANE_INDEX[key];
        const flash = document.querySelector(`.lane-flash[data-lane="${idx}"]`);
        if (flash) flash.classList.remove("active");

        const note = longNoteHold[key];
        if (note) {
          const now = audio.currentTime * 1000;
          const end = note.start + note.dur;

          // processed済みの場合はすでにCompleteしているので何もしない（重要）
          if (note.processed) {
            longNoteHold[key] = null;
            return;
          }

          if (now < end - 200) {
            triggerMiss(note);
          } else {
            completeLongNote(note);
          }
          longNoteHold[key] = null;
        }
      }

      function completeLongNote(note) {
        if (note.processed) return;
        note.processed = true;
        note.hit = true;
        if (note.el) note.el.style.display = "none";
        addScore(500);
        showFeedback(note.laneKey, "COMPLETE", "#ff0");
        // ホールド解除（重要：これをしないとhandleInputEndで再判定される恐れ）
        if (longNoteHold[note.laneKey] === note) {
          longNoteHold[note.laneKey] = null;
        }
      }

      function triggerMiss(note) {
        if (note.processed) return;
        note.processed = true;
        note.hit = false;
        if (note.el) note.el.style.opacity = 0.3;

        if (longNoteHold[note.laneKey] === note)
          longNoteHold[note.laneKey] = null;

        combo = 0;
        updateScore();
        showFeedback(note.laneKey, "MISS", "#555");
      }

      /* --- Visuals --- */
      function drawVisualizer() {
        if (!analyser) return;
        analyser.getByteFrequencyData(dataArray);
        vCtx.clearRect(0, 0, vCanvas.width, vCanvas.height);
        const barW = vCanvas.width / dataArray.length;
        for (let i = 0; i < dataArray.length; i++) {
          const val = dataArray[i];
          const h = (val / 255) * vCanvas.height * 0.4;
          const hue = (i / dataArray.length) * 360;
          vCtx.fillStyle = `hsla(${hue}, 80%, 50%, 0.2)`;
          vCtx.fillRect(i * barW, vCanvas.height - h, barW + 1, h);
        }
      }

      function updateParticles() {
        pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);
        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.life -= 0.04;
          if (p.life <= 0) particles.splice(i, 1);
          else {
            pCtx.globalAlpha = p.life;
            pCtx.fillStyle = p.c;
            pCtx.beginPath();
            pCtx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
            pCtx.fill();
          }
        }
        pCtx.globalAlpha = 1;
      }

      function spawnHitEffect(key, col) {
        const zone = document.querySelector(`.input-zone[data-key="${key}"]`);
        const rect = zone.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top;
        for (let i = 0; i < 12; i++) {
          particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 15 - 5,
            life: 1,
            c: col,
            s: Math.random() * 5 + 2,
          });
        }
      }
      function spawnSparkle(key) {
        spawnHitEffect(key, "#fff");
      }

      function showFeedback(key, txt, col) {
        const zone = document.querySelector(`.input-zone[data-key="${key}"]`);
        const old = zone.querySelector(".feedback-text");
        if (old) old.remove();

        const el = document.createElement("div");
        el.className = "feedback-text";
        el.innerText = txt;
        el.style.color = col;
        zone.appendChild(el);
        setTimeout(() => el.remove(), 600);
      }

      function addScore(p) {
        score += p + combo * 10;
        combo++;
        if (combo > maxCombo) maxCombo = combo;
        updateScore();
        comboNum.innerText = combo;
        comboBox.classList.remove("show");
        void comboBox.offsetWidth;
        if (combo > 1) comboBox.classList.add("show");
      }
      function updateScore() {
        scoreEl.innerText = score;
      }

      function endGame() {
        stopGameLoop();
        isPlaying = false;
        document.getElementById("result-screen").style.display = "flex";
        document.getElementById(
          "result-stats"
        ).innerHTML = `SCORE: ${score}<br>MAX COMBO: ${maxCombo}`;
      }
    </script>
  </body>
</html>
